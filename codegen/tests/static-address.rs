extern crate holyjit_codegen as codegen;
extern crate holyjit_lir as lir;

use codegen::*;
use std::mem;

use lir::unit::*;
use lir::data_flow::*;
use lir::number::*;
use lir::builder::*;
use lir::types::*;

mod lib;
use lib::*;

// Emulate what is expected to be generated by HolyJIT for resolving symbols
// addresses, such as functions.
const CST : u8 = 42;
const JIT_REFS : (u8, &'static u8) = (51, &CST);

#[test]
fn load_first_static_field() {
    let mut ctx_bld = ContextBuilder::new();
    let unit = {
        let mut bld = UnitBuilder::new(UnitId::Function(0), &mut ctx_bld);
        // Add the function signature.
        let t_u8 = bld.ctx().add_type(ComplexType::new_scalar(NumberType::U8));
        let t_sig = bld.ctx().add_type(ComplexType::new_fn(vec![], vec![t_u8], CanUnwind(true)));
        let ref0 = bld.ctx().add_typed_ref::<u8>();
        let _ref1 = bld.ctx().add_typed_ref::<&u8>();
        bld.set_signature(t_sig);
        let s0 = bld.create_sequence();
        {
            bld.set_entry(s0);
            bld.switch_to_sequence(s0);
            let v0 = bld.add_op(Opcode::StaticAddress, &[]);
            let v1 = bld.add_op(Opcode::Const((addr_type(), ref0).into()), &[]);
            let v2 = bld.add_op(Opcode::Add(addr_type()), &[v0, v1]);
            let v3 = bld.add_op(Opcode::Load(t_u8), &[v2]);
            bld.end_op(Opcode::Return, &[v3]);
        }
        bld.finish()
    };
    let mut ctx = ctx_bld.finish();
    ctx.set_static_refs(&JIT_REFS);

    let mut cg = CodeGenerator::new();
    let code = cg.compile(&ctx, &unit).unwrap();
    let f : fn() -> u8 = unsafe {
        mem::transmute(code.as_ptr())
    };
    assert_eq!(f(), JIT_REFS.0);
}

#[test]
fn load_second_static_field() {
    let mut ctx_bld = ContextBuilder::new();
    let unit = {
        let mut bld = UnitBuilder::new(UnitId::Function(0), &mut ctx_bld);
        // Add the function signature.
        let t_u8 = bld.ctx().add_type(ComplexType::new_scalar(NumberType::U8));
        let t_ptr = bld.ctx().add_type(ComplexType::new_scalar(addr_type()));
        let t_sig = bld.ctx().add_type(ComplexType::new_fn(vec![], vec![t_u8], CanUnwind(true)));
        let _ref0 = bld.ctx().add_typed_ref::<u8>();
        let ref1 = bld.ctx().add_typed_ref::<&u8>();
        bld.set_signature(t_sig);
        let s0 = bld.create_sequence();
        {
            bld.set_entry(s0);
            bld.switch_to_sequence(s0);
            let v0 = bld.add_op(Opcode::StaticAddress, &[]);
            let v1 = bld.add_op(Opcode::Const((addr_type(), ref1).into()), &[]);
            let v2 = bld.add_op(Opcode::Add(addr_type()), &[v0, v1]);
            let v3 = bld.add_op(Opcode::Load(t_ptr), &[v2]);
            let v4 = bld.add_op(Opcode::Load(t_u8), &[v3]);
            bld.end_op(Opcode::Return, &[v4]);
        }
        bld.finish()
    };
    let mut ctx = ctx_bld.finish();
    ctx.set_static_refs(&JIT_REFS);

    let mut cg = CodeGenerator::new();
    let code = cg.compile(&ctx, &unit).unwrap();
    let f : fn() -> u8 = unsafe {
        mem::transmute(code.as_ptr())
    };
    assert_eq!(f(), *JIT_REFS.1);
}

