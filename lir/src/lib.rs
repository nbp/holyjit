#![feature(slice_rotate)]
/// The LIR format is used for encoding the Rust code which would be optimized
/// at compile time and the also at runtime. It should mostly be generated by
/// the holyjit driver, and consumed by the holyjit compiler.
///
/// This format is made to optimize for recompilation. Optimizing for
/// recompilation is extremely interesting for a JIT as a JIT work is mostly
/// composed of recompilation. For example, inlining is recompiling a compiled
/// function in another and an invalidation causes a few optimization to be
/// discarded when the same function is recompiled. Optimizing for recompilation
/// implies that we apply versionning ideas on this format, such that the cost
/// of a recompilation is less than the cost of the initial compilation.
///
/// This format is serializable because it has to be saved by the Rust driver,
/// in the data section of the generated program, and read at runtime by the
/// HolyJIT library.
///
/// The LIR is represented as a mix between a Sea-Of-Nodes and SSA, i-e that the
/// data-flow is the primary graph in which instructions are manipulated, and
/// then we have a control-flow graph which specify the ownership of Phi nodes
/// and control instruction.
///
/// One addition compared to the SSA notation and the sea-of-nodes approach for
/// manipulating the graph, is that this SSA notation is not using any
/// integer/pointer as indexes, but an index based on a stable hashing mechanism
/// such that we can patch the graph with the result of previous compilation.
// TODO: Add references to each part of the code in the previous comment.

// Serde is used for serializing and deserializing the LIR which is stored
// by the driver in a constant, and deserialized by the JIT compiler in
// order to be manipulated.
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate bincode;

pub mod unit;
pub mod number;
pub mod types;
pub mod data_flow;
pub mod control_flow;
pub mod context;
pub mod builder;
mod bitset;
